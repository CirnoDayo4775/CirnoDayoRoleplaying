<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Arknight : Endfield Base Planner By CirnoDayo4775</title>
    <meta name="description" content="Arknight Endfield building planner" />

<!-- Open Graph (Discord uses these) -->
<meta property="og:title" content="Arknight Endfield Planner">
<meta property="og:description" content="Arknight Endfield building planner with simple placement and lineout">
<meta property="og:type" content="website">
<meta property="og:url" content="https://cirnodayo4775.github.io/CirnoDayoRoleplaying/">
<meta property="og:image" content="https://pbs.twimg.com/media/G_gxFxUXsAAp6v4?format=jpg&name=medium">
    <script src="https://unpkg.com/konva@9/konva.min.js"></script>
    <style>
        body {
            margin: 0;
            display: flex;
            height: 100vh;
            font-family: sans-serif;
        }

        #palette {
            width: 200px;
            background: #111;
            color: white;
            padding: 10px;
        }

        #palette button {
            width: 100%;
            margin-bottom: 6px;
            padding: 6px;
            cursor: pointer;
        }

        #canvas {
            flex: 1;
            background: #222;
        }

        #toolbar {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            display: flex;
            gap: 5px;
            z-index: 1000;
        }
    </style>
</head>

<body>

    <div id="palette">
        <h3>Buildings</h3>
        <div id="building-list">Loading...</div>
    </div>

    <div id="canvas"></div>
<div id="toolbar"></div>
    <script>
        // === Belt direction definitions ===
const BELTS = [
  { id: "d_u", input: "â†‘", output: "up", symbol:"â†‘" },
  { id: "d_l", input: "â†°", output: "left", symbol:"â†°" },
  { id: "d_r", input: "â†±", output: "right", symbol:"â†±" },

  { id: "u_d", input: "â†“", output: "down", symbol:"â†“" },
  { id: "u_l", input: "â†²", output: "left", symbol:"â†²" },
  { id: "u_r", input: "â†³", output: "right", symbol:"â†³" },
  { id: "l_u", input: "-^", output: "up", symbol:"-^" },
  { id: "l_d", input: "â†´", output: "down", symbol:"â†´" },
  { id: "l_r", input: "â†’", output: "right", symbol:"â†’" },

  { id: "r_u", input: "^-", output: "up", symbol:"^-" },
  { id: "r_l", input: "â†", output: "left", symbol:"â†" },
  { id: "r_d", input: "â†µ", output: "down", symbol:"â†µ" }
];

const toolbar = document.getElementById("toolbar");

BELTS.forEach(belt => {
  const btn = document.createElement("button");
  btn.textContent = `${belt.symbol}`;

  btn.onclick = () => {
    selectedBuilding = null;
    currentTool = {
      type: "belt",
      input: belt.input,
      output: belt.output
    };
  };

  toolbar.appendChild(btn);
});
/*const saveBtn = document.createElement("button");
saveBtn.textContent = "Save";
toolbar.appendChild(saveBtn);

const loadBtn = document.createElement("button");
loadBtn.textContent = "Load";
toolbar.appendChild(loadBtn);

saveBtn.onclick = saveToJSON;

loadBtn.onclick = () => {
    const json = prompt("Paste JSON here:");
    if (json) loadFromJSON(json);
};*/




        /* ===== CONFIG ===== */
        let buildingsstructure = [];
        const powerZones = [];
        function createPowerZone(gx, gy) {
            const size = 12;
            const half = size / 2;

            return {
                x1: gx - half + 1,
                y1: gy - half + 1,
                x2: gx - half + 1 + size,
                y2: gy - half + 1 + size
            };
        }
        const TILE = 32;
        const GRID_W = 50;
        const GRID_H = 30;
        const API_URL = "https://script.googleusercontent.com/macros/echo?user_content_key=AehSKLhoXBhrhYZnfWqZtL_jyAvfE9uXK-Qg2XU5QJpcX2q16EP3NcEIBMxGGLJ4iqWsSWDWEikpwjJdpkfjI4fr3KguQPBDHjF4xrA8fnkAgLYh-n534IyMjysxDr3FW_i6Jxu2Oqa7bjL7JEr1Qu7Oj0cfFoPTL405D3Ex9JT3B42FP4eJP3W1qmeO2Xg_G3SVekqMtcoFXOfaLOtUsLrQHk-GUMbU_cQMJQBTy2XRPlGu1ghI5YJnufuxonlQSbDUPnY6RsQmtIsASK3WVNO9amlu6-eCng9WwPukbmRk&lib=MKWJY44n4gVbzeljBoklb3v0wnDUGejc4";
        window.addEventListener('contextmenu', e => e.preventDefault());

        /* ===== STATE ===== */
        let selectedBuilding = null;
        let currentTool = null;
        let rotateFlag = false;

        /* Setup for rotation */
        window.addEventListener("keydown", e => {
    if (e.key.toLowerCase() === "r") {
        rotateFlag = !rotateFlag;
        console.log("Rotate:", rotateFlag ? "ON" : "OFF");
    }
});


        /* ===== KONVA SETUP ===== */
        const stage = new Konva.Stage({
            container: 'canvas',
            width: window.innerWidth - 200,
            height: window.innerHeight
        });

        const gridLayer = new Konva.Layer();
        const powerLayer = new Konva.Layer();
        const buildLayer = new Konva.Layer();

        stage.add(gridLayer);
        stage.add(powerLayer);
        stage.add(buildLayer);

        /* ===== DRAW GRID ===== */
        for (let x = 0; x <= GRID_W; x++) {
            gridLayer.add(new Konva.Line({
                points: [x * TILE, 0, x * TILE, GRID_H * TILE],
                stroke: '#333',
                strokeWidth: 1
            }));
        }
        for (let y = 0; y <= GRID_H; y++) {
            gridLayer.add(new Konva.Line({
                points: [0, y * TILE, GRID_W * TILE, y * TILE],
                stroke: '#333',
                strokeWidth: 1
            }));
        }
        gridLayer.draw();

        /* ===== FETCH BUILDINGS ===== */
        fetch(API_URL)
            .then(r => r.json())
            .then(buildings => {
                buildingsstructure = buildings;
                const list = document.getElementById('building-list');
                list.innerHTML = "";

                buildings.forEach(b => {
                    const btn = document.createElement('button');
                    btn.textContent = b.name;
                    btn.onclick = () => {
                        currentTool = null;  
                        selectedBuilding = b;
                    };
                    list.appendChild(btn);
                });
            });

        /* ===== PLACE BUILDING ===== */
        stage.on('click', e => {
            // ONLY left click
            if (e.evt.button !== 0) return;

            // Don't place if clicking on existing object
            if (e.target !== stage) return;

            // ===== PLACE BELT =====
if (currentTool?.type === "belt") {
    const pos = getWorldPointer();
    const gx = Math.floor(pos.x / TILE);
    const gy = Math.floor(pos.y / TILE);

    // simple 1x1 overlap check
    if (isOverlapping(gx, gy, 1, 1)) return;

    placeBelt(gx, gy, currentTool);
    return; // â›” stop here, do NOT place building
}


            if (!selectedBuilding) return;

            const pos = getWorldPointer();
            const gx = Math.floor(pos.x / TILE);
            const gy = Math.floor(pos.y / TILE);

            const w = rotateFlag ? selectedBuilding.h : selectedBuilding.w;
const h = rotateFlag ? selectedBuilding.w : selectedBuilding.h;

if (isOverlapping(gx, gy, w, h)) {
    return;
}


            

            const group = new Konva.Group({
                
                x: gx * TILE,
                y: gy * TILE
            });

            group._grid = {
    x: gx,
    y: gy,
    w: w,
    h: h
};


            const rect = new Konva.Rect({
                x: 0,
                y: 0,
                width: w * TILE,
                height: h * TILE,
                fill: selectedBuilding.color,
                stroke: 'black',
                strokeWidth: 1
            });
            const text = new Konva.Text({
                text: selectedBuilding.name,
                width: w * TILE,
                height: h * TILE,
                align: 'center',
                verticalAlign: 'middle',
                fill: '#000',
                fontSize: 12,
                listening: false // text doesn't intercept clicks
            });
            if (selectedBuilding.id === "power") {
                rect.stroke('#ff9800');
                rect.strokeWidth(2);

            }

            group.on('contextmenu', e => {
                e.evt.preventDefault();

                // Remove power logic
                if (group._powerZone) {
                    powerZones.splice(powerZones.indexOf(group._powerZone), 1);
                }

                // Remove power visuals
                if (group._powerZoneRect) {
                    group._powerZoneRect.destroy();
                }

                // Remove building
                group.destroy();

                buildLayer.draw();
                gridLayer.draw();
            });


            group.add(rect);
            group.add(text);

            let zone = null;
            let zoneRect = null;

            if (selectedBuilding.id === "power") {
                zone = createPowerZone(gx, gy);
                powerZones.push(zone);

                zoneRect = drawPowerZone(zone);

                // link ownership
                group._powerZone = zone;
                group._powerZoneRect = zoneRect;
            }


            buildLayer.add(group);
            buildLayer.draw();
        });
        /* ===== PAN & ZOOM ===== */
        let isPanning = false;
        let lastPos = null;

        stage.on('mousedown', e => {
            // Right mouse button
            if (e.evt.button === 2 && e.target === stage) {
                isPanning = true;
                lastPos = stage.getPointerPosition();
            }
        });

        stage.on('mousemove', () => {
            if (!isPanning) return;

            const pos = stage.getPointerPosition();
            const dx = pos.x - lastPos.x;
            const dy = pos.y - lastPos.y;

            stage.x(stage.x() + dx);
            stage.y(stage.y() + dy);
            stage.batchDraw();

            lastPos = pos;
        });

        stage.on('mouseup', () => {
            isPanning = false;
        });

        const SCALE_BY = 1.05;

        stage.on('wheel', e => {
            e.evt.preventDefault();

            const oldScale = stage.scaleX();
            const pointer = stage.getPointerPosition();

            const mousePointTo = {
                x: (pointer.x - stage.x()) / oldScale,
                y: (pointer.y - stage.y()) / oldScale
            };

            const direction = e.evt.deltaY > 0 ? -1 : 1;
            const newScale = direction > 0
                ? oldScale * SCALE_BY
                : oldScale / SCALE_BY;

            stage.scale({ x: newScale, y: newScale });

            const newPos = {
                x: pointer.x - mousePointTo.x * newScale,
                y: pointer.y - mousePointTo.y * newScale
            };

            stage.position(newPos);
            stage.batchDraw();
        });


        function getWorldPointer() {
            const pointer = stage.getPointerPosition();
            const scale = stage.scaleX();

            return {
                x: (pointer.x - stage.x()) / scale,
                y: (pointer.y - stage.y()) / scale
            };
        }

        //Overlapped detection

        function isOverlapping(gx, gy, gw, gh) {
            const nodes = buildLayer.getChildren();

            for (const node of nodes) {
                if (!node._grid) continue;

                const a = {
                    x1: gx,
                    y1: gy,
                    x2: gx + gw,
                    y2: gy + gh
                };

                const b = {
                    x1: node._grid.x,
                    y1: node._grid.y,
                    x2: node._grid.x + node._grid.w,
                    y2: node._grid.y + node._grid.h
                };

                // AABB overlap check
                if (
                    a.x1 < b.x2 &&
                    a.x2 > b.x1 &&
                    a.y1 < b.y2 &&
                    a.y2 > b.y1
                ) {
                    return true;
                }
            }

            return false;
        }

        function drawPowerZone(zone) {
            const zoneRect = new Konva.Rect({
                x: zone.x1 * TILE,
                y: zone.y1 * TILE,
                width: (zone.x2 - zone.x1) * TILE,
                height: (zone.y2 - zone.y1) * TILE,
                fill: 'rgba(255, 255, 0, 0.25)', // slightly stronger
                stroke: 'rgba(255, 255, 0, 0.6)', // ðŸ‘ˆ outline helps a LOT
                strokeWidth: 1,
                listening: false
            });

            powerLayer.add(zoneRect);
            powerLayer.draw();

            return zoneRect;
        }



        function addPowerZone(gx, gy) {
            // power node is 2x2, radius = 5 tiles
            const zone = {
                x1: gx - 5,
                y1: gy - 5,
                x2: gx + 2 + 5,
                y2: gy + 2 + 5
            };

            powerZones.push(zone);

            const zoneRect = new Konva.Rect({
                x: zone.x1 * TILE,
                y: zone.y1 * TILE,
                width: (zone.x2 - zone.x1) * TILE,
                height: (zone.y2 - zone.y1) * TILE,
                fill: 'rgba(255, 255, 0, 0.15)',
                listening: false
            });

            gridLayer.add(zoneRect);
            gridLayer.draw();

            return zoneRect;
        }

        function placeBelt(gx, gy, belt) {
    const group = new Konva.Group({
        
        x: gx * TILE,
        y: gy * TILE
    });
    group._buildingId = selectedBuilding.id;


    // grid info for overlap
    group._grid = {
        x: gx,
        y: gy,
        w: 1,
        h: 1
    };

    // belt body
    const rect = new Konva.Rect({
        x: 0,
        y: 0,
        width: TILE,
        height: TILE,
        fill: '#f5c987',
        stroke: '#222',
        strokeWidth: 1
    });

    // arrow text (input â†’ output)
    const arrowText = new Konva.Text({
        text: `${belt.input}`,
        width: TILE,
        height: TILE,
        align: 'center',
        verticalAlign: 'middle',
        fontSize: 14,
        fill: '#000',
        listening: false
    });

    // save belt data
    group._belt = {
        input: belt.input,
        output: belt.output,
        symbol: belt.symbol
    };

    // right-click delete
    group.on('contextmenu', e => {
        e.evt.preventDefault();
        group.destroy();
        buildLayer.draw();
    });

    group.add(rect);
    group.add(arrowText);
    buildLayer.add(group);
    buildLayer.draw();
}

function saveToJSON() {
    console.log('children:', buildLayer.getChildren().map(n => n.className));
console.log('groups:', buildLayer.find('Group'));

    const data = [];

    buildLayer.find('Group').forEach(node => {
        if (node._belt) {
            data.push({
                type: "belt",
                x: node._grid.x,
                y: node._grid.y,
                input: node._belt.input,
                output: node._belt.output
            });
        }
        else if (node._grid && node._buildingId) {
            data.push({
                type: "building",
                id: node._buildingId,
                x: node._grid.x,
                y: node._grid.y
            });
        }
    });

    const json = JSON.stringify(data, null, 2);
    navigator.clipboard.writeText(json);
    alert("Saved to clipboard!");
}


function loadFromJSON(json) {
    const data = JSON.parse(json);

    clearMap();

    data.forEach(item => {
        if (item.type === "belt") {
            placeBelt(item.x, item.y, {
                input: item.input,
                output: item.output,
                symbol: item.input
            });
        }

        if (item.type === "building") {
            const def = buildingsstructure.find(b => b.id === item.id);
            if (!def) return;

            placeBuildingFromLoad(def, item.x, item.y);
        }
    });
}

function placeBuildingFromLoad(def, gx, gy) {
    const group = new Konva.Group({
        x: gx * TILE,
        y: gy * TILE
    });

    group._grid = {
        x: gx,
        y: gy,
        w: def.w,
        h: def.h
    };

    group._buildingId = def.id;

    const rect = new Konva.Rect({
        width: def.w * TILE,
        height: def.h * TILE,
        fill: def.color,
        stroke: 'black',
        strokeWidth: 1
    });

    const text = new Konva.Text({
        text: def.name,
        width: def.w * TILE,
        height: def.h * TILE,
        align: 'center',
        verticalAlign: 'middle',
        fontSize: 12,
        listening: false
    });

    // power node logic
    if (def.id === "power") {
        rect.stroke('#ff9800');
        rect.strokeWidth(2);

        const zone = createPowerZone(gx, gy);
        powerZones.push(zone);

        const zoneRect = drawPowerZone(zone);
        group._powerZone = zone;
        group._powerZoneRect = zoneRect;
    }

    // right-click delete (FIXED)
    group.on('contextmenu', e => {
        e.evt.preventDefault();

        if (group._powerZone) {
            powerZones.splice(powerZones.indexOf(group._powerZone), 1);
        }
        if (group._powerZoneRect) {
            group._powerZoneRect.destroy();
        }

        group.destroy();
        buildLayer.draw();
        powerLayer.draw();
    });

    group.add(rect);
    group.add(text);
    buildLayer.add(group);
    buildLayer.draw();
}



function clearMap() {
    buildLayer.destroyChildren();
    powerLayer.destroyChildren();
    powerZones.length = 0;

    buildLayer.draw();
    powerLayer.draw();
}

    </script>

</body>

</html>